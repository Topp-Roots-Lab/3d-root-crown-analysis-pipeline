# 3-D Root Crown Analysis Pipeline

Stable version: 1.7.0

Compatibility: Python 3.8 or newer

This set of tools and scripts as a pipeline to analyze 3-D volumes of maize root crowns.

This pipeline is composed of four modules, and as such, these are depencides:
1. Data preprocessing: [python-rawtools](https://github.com/Topp-Lab-Roots/python-rawtools/)
1. 

- [Installation](#installation)
- [Input & Output](#input)
  - [Description of Traits](#description-of-traits)
- [Usage](#usage)
- [Descriptions](#description)
- [Workflow](#workflow)
- [Troubleshooting](#troubleshooting)
- [Additional Information](#additional-information)
- [Credits](#credits)

## Installation

See installation guide [here](INSTALL.md).

## Input

The input data consists of a `.RAW` and its paired `.DAT` file. Both of these can be generated by the NorthStar Imaging (NSI) efX-CT Software by exporting a `.RAW` volume. By default, the volume is assumed to be in unsigned 16-bit format.

## Output

The results of this pipeline are a `.TSV` of features and a `.CSV` of traits calculated from the provided volume.

### Description of Traits

Data Structures
Voxset
an unordered set of voxels that represent an object of interest, represented by linear indices converted from coordinate space. This is extended from a hashmap/set data structure.

When creating the voxset representation, all of the connected components are calculated. Any connected component smaller than the largest is removed--leaving one singular connected component.

Additionally, any cavities for the largest connected component are filled.
Root System
A voxset representation of point cloud data (.out)
Skeleton
A voxset representation of skeletonized point cloud data

SurfaceArea
	Count of exposed faces of root system
Volume
Count of voxels that represent a root system
ConvexVolume
	Total volume computed by qhull library (v2012.1)
Solidity
	The ratio of the volume to the convex hull volume
VolumeConvexVolume
MedR
The 50th percentile of the number of connected components for all slices. The number of connected components represent the number of roots that intersect a given slice.

The slices are ordered in ascending order from least number of roots to greatest, and the slice that falls on the 50th percentile is reported as the MedR. If the depth is an even number, it reports the average of the 50th percentile and that of the next lower number of roots for a given slice.
MaxR
The 84th percentile of the number of connected components for all slices. The number of connected components represent the number of roots that intersect a given slice.

The slices are ordered in ascending order from least number of roots to greatest, and the slice that falls on the 84th percentile is reported as the MaxR.
Bushiness
The ratio of MaxR to MedR.
Depth
The difference in the number of voxels between the first slice and the deepest slice.
	The slices are 0-indexed, so 1 is added.
slicen-slice0+1 
HorEqDiameter
Largest value for widthS=2volumeCH,S, given the volume of the convex hull for any slice along the vertical axis, ignoring edge cases where volume cannot be defined. Convex hull is calculated by qhull library (v2012.1).

This is either referred to as the maximum horizontal distance for all slices or the equivalent diameter of the convex hull.


TotalLength
Count of voxels that represent a skeleton of the root system. 
SRL
	Ratio of total root length to volume
TotalLengthVolume
Length_Distr
The ratio of root length in the upper 1⁄3 of the volume to the root length in the lower 2⁄3 of the volume.

Note, the root length for each is the number of voxels present in the skeleton for their respective portion relative to the depth. I labeled this feature as calculated using both the skeleton and PCD because the depth is calculated using the PCD, and the length is calculated using the voxels that make up the skeleton.
W_D_ratio
The ratio of the HorEqDiameter to the depth.
HorEqDiameterDepth
NumberBifCl
The number of connected components made up of neighboring branches in the skeleton.
AvgSizeBifCl
The total number of voxels for all connected components of neighboring branches divided by the number of bifurcation clusters. I.e., the average number of voxels for each bifurcation cluster (connected component with more than two neighboring voxels/branches)
EdgeNum
Number of edges, “sequence of neighboring voxels”, excluding sequences that end with a tip. Each edge ends at its starting voxel or a bifurcation cluster. Sequences that end with a tip are excluded.
AvgEdgeLength
Sum of the length of all edges calculated from the skeleton divided by the number of edges. The length of each edge is the euclidean distance traversed by walking along each edge, voxel by voxel.
Number_tips
Number of root tips
volume
The sum of squares of estimated iterations needed to erode the shape of the PCD until it forms a one-voxel wide curve, multiplied by pi. I.e., r2for each voxel where the radius is the number of iterations to erode down to a skeleton.
Surface_area
The sum of estimated iterations needed to erode the shape of the PCD until it forms a one-voxel wide curve, multiplied by 2.
av_radius
Create voxset from PCD
Copy PCD voxset to “skel” object and then “create skeleton” using 2.25 as scale. This scale is “complexity,” not the resolution/dimensions of the voxels.
Create a hash_map to store erosion distances (distR)
Apply thinning (palagyi filter) via the applyWdist function provided by Patrick Min’s binvox and thinvox libraries. 

“Erosion distance is computed during the thinning algorithm, it is estimated by the number of the iterations which it takes to erode the shape til one-voxel wide curve.”

The code boils down to surface_area divided by the number of voxels in the skeleton. However, the surface_area appears to be calculated from the distance transformation map that is calculated by external libraries thinvox and binvox (https://www.patrickmin.com/thinvox/). So I don’t know the exact details of how the values are calculated, but if the above quote taken from a comment in the source code is correct, it is the estimated number of iterations needed to create a one-voxel wide curve.

Going off of this, the average radius may be the average number of iterations needed to create the skeleton from the PCD. Assuming that each iteration would remove 0 to 1 voxels were iteration, this would be a proxy for the radius of a curve/root in voxel units.


SurfaceArea
Area of voxel faces on the surface of the root networkThe sum of the local surface area at each voxel in the root network.
PCD
Volume
The sum of the local volumes at each voxel in the root network; also referred to as “biomass.”
PCD
ConvexVolume
The volume of the convex hull that encompasses the root network.
PCD
Solidity
The total network volume divided by the network convex volume.
PCD
MedRoots
Median number of roots among all horizontal slices.
PCD
MaxRoots
84th percentile value of the number of roots among all horizontal slices.
PCD
Bushiness
The ratio of the maximum to the median number of roots.
PCD
Depth
The number of voxels in the vertical direction of the root network.
PCD
HorEqDiameter
Maximum root network system width along a vertical axis.
PCD
TotalLength
Root length as approximated by the number of voxels in the skeleton.
Skeleton
SRL
Specific root length; the total network length divided by the network volume.
Skeleton & PCD
LengthDistr
The ratio of root length in the upper 1⁄3 of the volume to the root length in the lower 2⁄3 of the volume.
Skeleton & PCD
WD_Ratio
Width-to-depth ratio; the maximum root network width divided by the network depth.
PCD
NumberBifCl
The number of connected components formed by all bifurcation voxels in the skeleton (i.e. voxels that have more than two neighbors)
Number of bifurcation clusters.
Skeleton
AvgSizeBifCl
Average size of the bifurcation clusters (i.e. the number of neighbors)
.
Skeleton
EdgeNum
Number of skeleton edges that span bifurcation clusters.
Skeleton
AvgEdgeLength
Average length between skeleton bifurcation clusters.
Skeleton
NumberTips
Number of root tips.
Skeleton
AvgRadius
The average radius of all voxels in the skeleton.
Skeleton & PCD



Pseudo-code/Technical Descriptions


HorEqDiameter
For each slice in root system
Gather voxels for slice and calculate width
Case A: 0 voxels -> skip to next slice
Case B: 1 voxel
Set widthS = 0 and continue to step 2
Case C: 2 voxels
Set widthS = euclidean distance between two voxels and continue to step 2
Case D: 3 or more voxels
Measure volume of convex hull of the slice (volumeCH,S) (qhull v2012.1) and continue to step 2
widthS=2volumeCH,S
If widthS is larger than the current known maximum width, set it to the widthS.
Once each slice has been checked for a greater width, return the largest as HorEqDiameter.

Depth
	The difference in the number of voxels between the first slice and the deepest slice.
	The slices are 0-indexed, so 1 is added.
slicen-slice0+1 

MaxR
For each slice in root system
Gather the voxels for slice and convert them into a number of connected components (i.e., join neighboring voxels into a single unit, 26-neighbor method)
Store number of components in an unordered list
Once the number of connected components for each slice is calculated, sort in ascending order.

Return roughly the 84th percentile of the number of connected components for all slices by on depth.



MedR
For each slice in root system
Gather the voxels for slice and convert them into a number of connected components (i.e., join neighboring voxels into a single unit, 26-neighbor method)
Store number of components in an unordered list
Once the number of connected components for each slice is calculated, sort in ascending order.


Depending on the depth (i.e., total number of slices), there are two cases.
There are an odd number of slices (odd depth), return 50th percentile count of connected components for all slices.
There are an even number of slices (even depth), return the 50th percentile count of connected components for all slices averaged with the next lower count of connected components for a slice.

NumberBifCl
For each voxel in the skeleton
If the voxel has more than two neighboring voxels, create a branch and add it to a list of known branches.

Note, this is stored in a hash_set/unordered_set using the linear index of the voxel “borrowed” from the skeleton’s voxset representation


Once every branch has been created, initialize a queue with the first branch found. We want to collect the branching nodes into connected components.


For each known branch, create a connected component for neighboring branches.

The number of connected components made up of neighboring branches is the number of bifurcation clusters.

EdgeNum & AvgEdgeLength
For each voxel in the skeleton
Count the number of voxels that are members of bifurcation clusters and not, separated into two collections: cluster “branch” & non-cluster “non-branch” voxels.
Branch = more than two neighboring voxels
Non-branch = 2 or fewer neighboring voxels
Collect all non-branching voxels belonging to the same branch
For each non-branching voxel, find its neighbors (should be 2 or fewer total). This is effectively looking for a “straight shot” down the root.
If no neighbors are found, expand search to branch voxels. When a voxel from a neighboring branch is found, add the neighboring voxel to the edge, end edge, and continue to step 1ai for the next non-branching voxel.
If no neighbors were found and no neighboring branches were found, it’s a root tip and the edge is completed. This voxel is flagged as a root tip and the “start” of an edge. Continue to step 1ai for the next non-branching voxel.
[NEED TO CONFIRM] Sort indices of edges by branching point (MedialCurve.cpp, Lineno. 591-625)
Iterate over all voxels in the skeleton and count the number of voxels with exactly one neighbor; this is the number of root tips.
For each edge that does not end with a root tip (i.e., only the length of root that connect by bifurcation clusters)
Count the number of edges
Sum the euclidean distance between each voxel that makes up each edge.

In other words, hop from voxel to voxel along an edge/root, adding up the distance of each, i=0v(xi+1-xi)2+(yi+1-yi)2+(zi+1-zi)2where v is the number of voxels that make up the edge, ordered.

Return number of edges as Edge_num, and return average length of edges by dividing the sum of the length of all edges by the number of edges.

av_radius
Create voxset from PCD
Copy PCD voxset to “skel” object and then “create skeleton” using 2.25 as scale. This scale is “complexity,” not the resolution/dimensions of the voxels.
Create a hash_map to store erosion distances (distR)
Apply thinning (palagyi filter) via the applyWdist function provided by Patrick Min’s binvox and thinvox libraries. 

“Erosion distance is computed during the thinning algorithm, it is estimated by the number of the iterations which it takes to erode the shape til one-voxel wide curve.”

The code boils down to surface_area divided by the number of voxels in the skeleton. However, the surface_area appears to be calculated from the distance transformation map that is calculated by an external library thinvox and binvox (https://www.patrickmin.com/thinvox/). So I don’t know the exact details of how the values are calculated, but if the above quote taken from a comment in the source code is correct, it is the estimated number of iterations needed to create a one-voxel wide curve.

Going off of this, the average radius may be the average number of iterations needed to create the skeleton from the PCD. Assuming that each iteration would remove 0 to 1 voxels were iteration, this would be a proxy for the radius of a curve/root in voxel units.





### Usage

See usage guide [here](USAGE.md).

This is an overview of the execution sequence for analyzing root crown x-ray scans.

<p align="center">
  <img alt="Root Crown Analysis Pipeline Flowchart" src="docs/img/root-crown-pipeline-flowchart.png">
</p>

### Troubleshooting

See troubleshooting guide [here](TROUBLESHOOTING.md).

If you encounter an unknown issues or would like additional assistance, please submit a GitHub issue: <https://github.com/Topp-Roots-Lab/3d-root-crown-analysis-pipeline/issues>

### Additional Information

## Issues & Bug Reporting

If you encounter any error, problem, or would like to suggest a feature, please submit a [git issue](https://github.com/Topp-Roots-Lab/3d-root-crown-analysis-pipeline/issues).


## Related Projects

* [python-rawtools](https://github.com/Topp-Roots-Lab/python-rawtools/): library for consuming and manipulating x-ray volume data in `.raw` format.
* [xrt-dmt](https://github.com/Topp-Roots-Lab/xrt-dmt) : data management tool for tracking and archiving XRT (meta)data


### Credits

This package was created with [Cookiecutter](https://github.com/audreyr/cookiecutter) and the [audreyr/cookiecutter-pypackage](https://github.com/audreyr/cookiecutter-pypackage) project template.
